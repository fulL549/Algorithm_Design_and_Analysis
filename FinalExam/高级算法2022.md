## 高级算法分析与设计期末考试题

### A*算法

#### 题目

1. 简述A*算法
2. 举一个可以用A*算法求解的例子
3. 描述上述例子中使用的启发式函数的设计思想

#### 解答

![](./images/83.png)
![](./images/84.png)
![](./images/85.png)
![](./images/86.png)
![](./images/87.png)
![](./images/88.png)

### Bin Pack Problem(二进制打包问题)

#### 题目

1. 描述FFD算法流程
2. 求解题目给出的Bin Pack问题的解
3. 证明FFD算法的近似比例为2（hint：有B-1个箱子使用了超过一半的空间）
> 看不懂 近似算法应该考得少 直接ai

#### 解答

**1. FFD (First Fit Decreasing) 算法流程**

1.  **排序**：将所有物品按体积（或重量）**从大到小**进行排序。
2.  **顺序装箱**：
    *   准备第一个空箱子。
    *   按排序后的顺序处理每一个物品。
    *   对于当前物品，从第一个箱子开始遍历已打开的箱子，尝试将其放入**第一个**剩余空间能容纳它的箱子中。
    *   如果已有的所有箱子都无法容纳该物品，则开启一个新的箱子并将物品放入。

**2. 求解题目给出的 Bin Pack 问题的解**

*(注：由于题目原文未提供具体物品数值，此处演示解题逻辑)*
假设物品大小为 $\{0.6, 0.5, 0.4, 0.4, 0.2\}$，箱子容量为 $1$。
1.  **排序**：已按降序排列 $0.6, 0.5, 0.4, 0.4, 0.2$。
2.  **装箱**：
    *   $0.6$: 放入 Bin 1 ($0.6/1.0$)。
    *   $0.5$: Bin 1 剩 $0.4$，放不下 ($0.5 > 0.4$) -> 放入 Bin 2 ($0.5/1.0$)。
    *   $0.4$: Bin 1 剩 $0.4$，刚好放下 -> 放入 Bin 1 ($1.0/1.0$)。
    *   $0.4$: Bin 1 满; Bin 2 剩 $0.5$，放下 -> 放入 Bin 2 ($0.9/1.0$)。
    *   $0.2$: Bin 1 满; Bin 2 剩 $0.1$，放不下 -> 放入 Bin 3 ($0.2/1.0$)。
3.  **结果**：共使用 3 个箱子。

**3. 证明 FFD 算法的近似比例为 2**

**证明思路**：利用提示“有 $B-1$ 个箱子使用了超过一半的空间”。

设 $OPT$ 为最优解使用的箱子数，$FFD$ 为 FFD 算法使用的箱子数 $m$。
设所有物品的总大小为 $S$，箱子容量为 $1$。

1.  **最优解下界**：
    显然，最优解必须能够容纳所有物品的总大小 $S$，即：
    $$ OPT \ge S $$

2.  **FFD 的空间利用性质**：
    假设 FFD 使用了 $m$ 个箱子。
    我们可以断言：**在使用的 $m$ 个箱子中，至少有 $m-1$ 个箱子的填充量超过 0.5**。
    *   **理由**：假设有两个箱子 $B_i$ 和 $B_j$ ($i < j$) 的填充量都 $\le 0.5$。
    *   这意味着 $B_i$ 至少有 $0.5$ 的剩余空间。
    *   $B_j$ 中的任何物品大小必然 $\le 0.5$（因为总填充量才 $\le 0.5$）。
    *   根据 First Fit 规则，当试图放入 $B_j$ 中的物品时，如果 $B_i$ 有剩余空间（这里 $>0.5$）且能容纳该物品（$\le 0.5$），它应该被放入 $B_i$ 而不是开启或放入更后面的 $B_j$。这产生了矛盾。
    *   因此，最多只有 1 个箱子填充量 $\le 0.5$，其余 $m-1$ 个箱子填充量均 $> 0.5$。

3.  **推导近似比**：
    所有物品的总大小 $S$ 等于所有箱子内物品之和：
    $$ S > 0.5 \times (m - 1) $$
    
    结合 $OPT \ge S$，我们有：
    $$ OPT > 0.5(m - 1) $$
    $$ 2 \cdot OPT > m - 1 $$
    
    因为 $m$ 和 $OPT$ 都是整数，$2 \cdot OPT > m - 1$ 意味着：
    $$ 2 \cdot OPT \ge m $$
    即：
    $$ \frac{m}{OPT} \le 2 $$
    得证。

### 线性规划

#### 题目

1. 画出给出的线性规划例子的可行域和目标解
2. 求上述例子的最优解
3. 将上述例子转化为标准型
4. 求该例子标准型的基解，和基可行解
转换：

![](./images/68.png)
![](./images/69.png)
![](./images/70.png)
![](./images/71.png)

图解法：

![](./images/66.png)
![](./images/67.png)

单纯性法：
![](./images/72.png)
![](./images/73.png)
![](./images/74.png)
![](./images/75.png)

> 单纯性表法不赘述

#### 解答

### 整数规划

#### 题目

1. 直接给出题中TSP问题的一个最优解
2. 将TSP问题用整数规划建模，如MTZ模型
3. 给出求解TSP问题下界的一个方法（LP Relaxation）
4. 描述一个求解TSP问题的算法（动态规划，状态压缩算法）
> 看不懂 TSP ppt的教学是使用搜索算法

#### 解答

**1. 直接给出题中TSP问题的一个最优解**

*(注：由于题目原文未给出具体距离矩阵，此处无法计算。通常对于 5-6 个点的小规模 TSP，可以通过观察找出权重最小的哈密顿回路。)*

**2. 将 TSP 问题用整数规划建模 (MTZ 模型)**

设 $n$ 为城市数量，$c_{ij}$ 为城市 $i$ 到 $j$ 的距离。
*   **决策变量**：$x_{ij}$，若路径包含从 $i$ 到 $j$ 的边则为 $1$，否则为 $0$。
*   **辅助变量**：$u_i$ ($i=2, \dots, n$)，代表城市 $i$ 在路径中的访问顺序序号。

模型如下：
$$
\begin{aligned}
\text{Minimize} \quad & \sum_{i=1}^n \sum_{j=1}^n c_{ij} x_{ij} \\
\text{Subject to} \quad & \sum_{j=1, j \neq i}^n x_{ij} = 1, \quad \forall i = 1, \dots, n \quad \text{(每个点出度为1)} \\
& \sum_{i=1, i \neq j}^n x_{ij} = 1, \quad \forall j = 1, \dots, n \quad \text{(每个点入度为1)} \\
& u_i - u_j + n \cdot x_{ij} \le n - 1, \quad \forall 2 \le i \neq j \le n \quad \text{(MTZ 子回路消除约束)} \\
& x_{ij} \in \{0, 1\} \\
& 1 \le u_i \le n-1
\end{aligned}
$$

**3. 求解 TSP 问题下界的一个方法 (LP Relaxation)**

**线性规划松弛 (LP Relaxation)** 的方法如下：
1.  **松弛约束**：将整数规划模型中的决策变量约束 $x_{ij} \in \{0, 1\}$ 替换（松弛）为 $0 \le x_{ij} \le 1$。
2.  **求解**：求解这个松弛后的线性规划 (LP) 问题。
3.  **结论**：因为 LP 的可行域包含了原整数规划 (IP) 的可行域，所以 LP 的最优目标函数值 $Z_{LP}$ 会小于或等于整数规划的最优解 $Z_{IP}$。
    *   因此，$Z_{LP}$ 构成了原 TSP 问题费用的一个**下界 (Lower Bound)**。

**4. 描述一个求解 TSP 问题的算法 (动态规划，状态压缩)**

使用 **Held-Karp 算法**（状态压缩 DP）：
*   **状态定义**：
    用一个二进制数 $S$ 表示已访问的城市集合（例如 $S=0011$ 表示访问了城市 0 和 1）。
    设 $dp[S][i]$ 表示从起点（城市 0）出发，恰好访问了集合 $S$ 中的所有城市，且最后停留在城市 $i$ 的最短路径长度。
*   **状态转移方程**：
    对于集合 $S$ 中的任意节点 $j$（$j \neq$ 起点），枚举 $S$ 中除 $j$ 以外的节点 $i$ 作为 $j$ 的前驱节点：
    $$ dp[S][j] = \min_{i \in S, i \neq j} \{ dp[S \setminus \{j\}][i] + c_{ij} \} $$
*   **初始化**：
    $dp[1 \ll 0][0] = 0$ （假设 0 号点为起点，只访问 0 号点且在 0 号点的距离为 0）。
*   **最终解**：
    遍历所有最后回到起点的路径，取最小值：
    $$ \text{Ans} = \min_{i=1}^{n-1} \{ dp[(1 \ll n) - 1][i] + c_{i0} \} $$


### Dijkstra 

#### 题目

1. 描述Dijkstra算法求解题中例子的流程
2. Dijkstra算法的伪代码

#### 解答

![](./images/46.png)
![](./images/47.png)
![](./images/48.png)
![](./images/49.png)

### 替代法

#### 题目

T(n)=2*T(n/2)+32n; T(2)=2

1. 描述替代法的三个步骤
2. 对题中问题用替代法三个步骤进行求解。

#### 解答

![](./images/11.png)

**1. 替代法的三个步骤**

1.  **猜测 (Guess)**：根据递归式的结构，猜测解的形式（例如 $O(n)$, $O(n \log n)$, $O(n^2)$ 等）。
2.  **验证 (Verify)**：使用**数学归纳法**来验证猜测的正确性。假设解对更小规模的输入（$n' < n$）成立，推导证明其对当前规模 $n$ 也成立，并找出使不等式成立的常数约束。
3.  **求解常数 (Solve for constants)**：利用递归式的边界条件（Base case）来求解或确定步骤 2 中引入的常数，从而完成证明。

**2. 求解过程**

**Step 1: 猜测解的形式**
观察递归式 $T(n) = 2T(n/2) + 32n$，从直观上（或主定理 Case 2）判断，猜测其解为 $O(n \log n)$。
我们猜测上界：$T(n) \le cn \log_2 n$。

**Step 2: 验证 (归纳证明)**
假设对于所有 $k < n$，都有 $T(k) \le ck \log_2 k$ 成立。
将 $k = n/2$ 代入递归式：
$$
\begin{aligned}
T(n) &= 2T(n/2) + 32n \\
&\le 2(c \cdot \frac{n}{2} \log_2 \frac{n}{2}) + 32n \quad (\text{代入归纳假设}) \\
&= cn(\log_2 n - \log_2 2) + 32n \\
&= cn \log_2 n - cn + 32n \\
&= cn \log_2 n - n(c - 32)
\end{aligned}
$$
为了证明 $T(n) \le cn \log_2 n$，我们需要余项 $-n(c - 32) \le 0$。
即：$c - 32 \ge 0 \Rightarrow c \ge 32$。

**Step 3: 求解常数 (处理边界条件)**
检查边界条件 $T(2) = 2$ 是否符合猜测。
$$
T(2) \le c \cdot 2 \cdot \log_2 2 = 2c
$$
我们需要 $2 \le 2c$，这要求 $c \ge 1$。


<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" }); </script>
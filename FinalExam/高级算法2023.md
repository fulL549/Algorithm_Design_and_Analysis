# 2023两种版本的试卷

## 春期高级算法与分析（专硕 ：戴智明）

### 第一题

A 集合中有n个元素，B 集合中有 m 个元素，并且 m=O(logn)。设计算法找出 A 集合和 B 集合的交集，并且分析时间复杂度。

#### 解答

B比较小，对B进行排序，时间复杂度O(m log m)，然后对A中的每个元素使用二分查找，时间复杂度O(n log m)，总时间复杂度O(n log m)。

### 第二题

一个普通的单纯形法求解最小值，但是求了两步之后就会发现最小值是负无穷。不是 PPT 上面能求出一个具体值的例子。
> 单纯形法，不赘述

### 第三题 

利用最短路法求最小费用最大流。其中 c 表示当前边的最大流量，w 表示单位流量的花费.

### 第四题

> 没有涉及

### 第五题

> 没有涉及

### 第六题 

求解 NP 完全问题的策略，并且给出例子（多项式时间近似算法除外）

- 随机算法：随机n皇后
- 固定参数法：最小顶点覆盖
- 启发式算法：模拟退火

#### 随机算法：随机n皇后
使用拉斯维加斯 (Las Vegas) 策略求解。
*   **策略**：按行放置皇后。在放置每一行时，计算所有安全（不冲突）的位置，并从中**均匀随机**选择一个位置放置。
*   **重置**：如果在某一行没有安全位置可放（进入死胡同），则算法宣告本次失败，清空棋盘，重新从第一行开始。
*   **特点**：虽然最坏情况可能一直找不到解，但在实际运行中，该算法往往能比确定性的回溯算法更快地找到一个解。

#### 固定参数法：最小顶点覆盖
利用有界搜索树 (Bounded Search Tree) 技术求解“是否存在大小不超过 $k$ 的顶点覆盖”。
*   **策略**：基于观察——对于图中的任意边 $(u, v)$，顶点覆盖集合必须包含 $u$ 或 $v$ (或两者)。
*   **算法流程**：
    1.  任选一条边 $(u, v)$。
    2.  分支 1：假设选择 $u$，则在剩下图 $G-\{u\}$ 中寻找大小不超过 $k-1$ 的覆盖。
    3.  分支 2：假设选择 $v$，则在剩下图 $G-\{v\}$ 中寻找大小不超过 $k-1$ 的覆盖。
*   **复杂度**：递归树深度最大为 $k$，节点数为 $2^k$，总时间复杂度为 $O(2^k \cdot n)$。当 $k$ 较小时非常高效。

#### 启发式算法：模拟退火
模拟物理退火过程的通用优化算法，常用于 TSP 等组合优化问题。
*   **策略**：
    1.  从一个随机初始解开始，设定初始高温 $T$。
    2.  **邻域扰动**：随机产生一个邻居解。
    3.  **接受准则**：如果邻居解更优，总是接受；如果更差，则以概率 $e^{-\Delta E / T}$ 接受（Metropolis 准则）。这允许算法跳出局部最优陷阱。
    4.  **降温**：随迭代进行逐渐降低 $T$，使得算法后期趋于稳定（贪心）。

### 第七题

集合覆盖，近似算法，伪代码，时间复杂度

#### 1. 问题定义

**输入：**
*   一个包含 $n$ 个元素的论域（Universe）集合 $U = \{e_1, e_2, \dots, e_n\}$。
*   一个由 $U$ 的子集组成的集合族 $\mathcal{S} = \{S_1, S_2, \dots, S_m\}$，满足 $\bigcup_{S \in \mathcal{S}} S = U$。

**输出：**
*   $\mathcal{S}$ 的一个子集合 $\mathcal{C}$，使得 $\mathcal{C}$ 中的所有集合的并集等于 $U$（即覆盖了所有元素）。
*   目标是使得 $\mathcal{C}$ 的大小 $|\mathcal{C}|$ **最小**。

*(这类问题是经典的 NP-hard 问题，通常很难在多项式时间内找到精确的最优解，因此常使用近似算法求解。)*

#### 2. 贪心近似算法 (Greedy Algorithm)

**算法思想：**
在该算法的每一步中，选择一个能够覆盖**最多尚未被覆盖元素**的集合。重复此过程，直到所有元素都被覆盖。

#### 3. 伪代码 (Pseudo-code)

```
Algorithm Greedy-Set-Cover(U, S)
    Input:  U (包含 n 个元素的集合), S (U 的子集族 {S1, ..., Sm})
    Output: C (覆盖 U 的子集族)

    1. C <- {}                  // 初始化结果集合为空
    2. R <- U                   // R 为剩余未被覆盖的元素集合
    
    3. while R is not empty do:
    4.     Select a subset Si from S that maximizes |Si ∩ R|
           // 选择一个能覆盖 R 中最多元素的集合 Si
    
    5.     C <- C U {Si}        // 将 Si 加入结果集
    6.     R <- R - Si          // 从未覆盖集合中移除 Si 包含的元素
    7.     S <- S - {Si}        // (可选) 从备选集合中移除 Si
    
    8. return C
```

#### 4. 时间复杂度分析

假设：
*   $n$ 是元素总数 ($|U|$)。
*   $m$ 是集合总数 ($|\mathcal{S}|$)。

因为每次至少覆盖 1 个新元素，所以 `while` 循环最多执行 $O(\min(n, m))$ 次（因为最多覆盖 $n$ 次，或者把 $m$ 个集合都选完）。
在每次迭代中，必须遍历所有剩余集合（最多 $m$ 个）来检查哪个集合覆盖了最多的剩余元素。对每个集合的检查涉及计算交集大小，耗时与 $n$ 成正比。

因此，朴素实现的最坏情况时间复杂度约为：
$$ O(m \cdot n \cdot \min(n, m)) $$

#### 5. 近似比计算

**结论：** 贪心算法的近似比为 **$H_n$** (第 $n$ 个调和数)。
$$ \rho = H_n = \sum_{k=1}^{n} \frac{1}{k} \approx \ln n $$

**证明思路：**
假设最优解 $OPT$ 使用了 $k$ 个集合。
在每一轮贪心选择时，剩余未覆盖元素 $R$ 一定能被 $OPT$ 中的这 $k$ 个集合覆盖。
根据鸽巢原理，必存在一个集合至少覆盖了 $|R|/k$ 个剩余元素。
贪心策略既然选了覆盖最多的那个，说明每一轮能减少至少 $1/k$ 比例的未覆盖元素。
由此递推，剩余未覆盖元素的数量按几何级数衰减，最终推导得出近似比为 $\ln n$。

### 第八题 

设计随机算法求解一个无向图的最小截(v1和v2)，使得v1和v2之间的边最少

求最小割等价于求最大流，求解最大流问题。

## 考试题回忆版

### 第一题

线性规划问题，写出对偶问题，计算最优解

![](/images/61.png)
![](/images/62.png)
![](/images/63.png)
![](/images/64.png)
![](/images/65.png)


### 第二题

给出一个矩阵，计算二部匹配（匈牙利算法）
![](/images/95.jpg)

### 第三题 

近似算法解集合覆盖，给出伪代码，复杂度
> 不赘述

### 第四题

分数背包和0/1背包
- 写出最优解递推方程
- 分析复杂度

#### 解答

![](/images/17.png)
![](/images/18.png)
![](/images/19.png)
![](/images/20.png)

### 第五题 

遗传算法
- 遗传算法的组成，原理
- 轮盘赌求概率
- pmx 


### 第六题

整数规划 

- 求松弛问题最优解
- 整数规划最优解
- 整数规划最优解和松弛问题最优解的关系
> 整数规划与分支界限，不赘述

### 第七题

TSP

- 直接给出题中TSP问题的一个最优解
- 将TSP问题用整数规划建模
- 给出求解TSP问题下界的一个方法
- 描述一个求解TSP问题的精确算法（动态规划）
> 不赘述